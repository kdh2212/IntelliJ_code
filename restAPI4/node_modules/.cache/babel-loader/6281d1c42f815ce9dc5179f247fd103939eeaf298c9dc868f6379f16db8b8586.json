{"ast":null,"code":"import _objectSpread from \"C:/_dev3/restAPI4/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"C:/_dev3/restAPI4/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"C:/_dev3/restAPI4/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _typeof from \"C:/_dev3/restAPI4/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _toConsumableArray from \"C:/_dev3/restAPI4/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n// Composables\nimport { useProxiedModel } from \"../proxiedModel.mjs\"; // Utilities\nimport { computed, inject, onBeforeMount, onBeforeUnmount, provide, ref, shallowRef, toRaw, toRef } from 'vue';\nimport { independentActiveStrategy, independentSingleActiveStrategy, leafActiveStrategy, leafSingleActiveStrategy } from \"./activeStrategies.mjs\";\nimport { listOpenStrategy, multipleOpenStrategy, singleOpenStrategy } from \"./openStrategies.mjs\";\nimport { classicSelectStrategy, independentSelectStrategy, independentSingleSelectStrategy, leafSelectStrategy, leafSingleSelectStrategy } from \"./selectStrategies.mjs\";\nimport { consoleError, getCurrentInstance, getUid, propsFactory } from \"../../util/index.mjs\"; // Types\nexport var VNestedSymbol = Symbol[\"for\"]('vuetify:nested');\nexport var emptyNested = {\n  id: shallowRef(),\n  root: {\n    register: function register() {\n      return null;\n    },\n    unregister: function unregister() {\n      return null;\n    },\n    parents: ref(new Map()),\n    children: ref(new Map()),\n    open: function open() {\n      return null;\n    },\n    openOnSelect: function openOnSelect() {\n      return null;\n    },\n    activate: function activate() {\n      return null;\n    },\n    select: function select() {\n      return null;\n    },\n    activatable: ref(false),\n    selectable: ref(false),\n    opened: ref(new Set()),\n    activated: ref(new Set()),\n    selected: ref(new Map()),\n    selectedValues: ref([]),\n    getPath: function getPath() {\n      return [];\n    }\n  }\n};\nexport var makeNestedProps = propsFactory({\n  activatable: Boolean,\n  selectable: Boolean,\n  activeStrategy: [String, Function, Object],\n  selectStrategy: [String, Function, Object],\n  openStrategy: [String, Object],\n  opened: null,\n  activated: null,\n  selected: null,\n  mandatory: Boolean\n}, 'nested');\nexport var useNested = function useNested(props) {\n  var isUnmounted = false;\n  var children = ref(new Map());\n  var parents = ref(new Map());\n  var opened = useProxiedModel(props, 'opened', props.opened, function (v) {\n    return new Set(v);\n  }, function (v) {\n    return _toConsumableArray(v.values());\n  });\n  var activeStrategy = computed(function () {\n    if (_typeof(props.activeStrategy) === 'object') return props.activeStrategy;\n    if (typeof props.activeStrategy === 'function') return props.activeStrategy(props.mandatory);\n    switch (props.activeStrategy) {\n      case 'leaf':\n        return leafActiveStrategy(props.mandatory);\n      case 'single-leaf':\n        return leafSingleActiveStrategy(props.mandatory);\n      case 'independent':\n        return independentActiveStrategy(props.mandatory);\n      case 'single-independent':\n      default:\n        return independentSingleActiveStrategy(props.mandatory);\n    }\n  });\n  var selectStrategy = computed(function () {\n    if (_typeof(props.selectStrategy) === 'object') return props.selectStrategy;\n    if (typeof props.selectStrategy === 'function') return props.selectStrategy(props.mandatory);\n    switch (props.selectStrategy) {\n      case 'single-leaf':\n        return leafSingleSelectStrategy(props.mandatory);\n      case 'leaf':\n        return leafSelectStrategy(props.mandatory);\n      case 'independent':\n        return independentSelectStrategy(props.mandatory);\n      case 'single-independent':\n        return independentSingleSelectStrategy(props.mandatory);\n      case 'classic':\n      default:\n        return classicSelectStrategy(props.mandatory);\n    }\n  });\n  var openStrategy = computed(function () {\n    if (_typeof(props.openStrategy) === 'object') return props.openStrategy;\n    switch (props.openStrategy) {\n      case 'list':\n        return listOpenStrategy;\n      case 'single':\n        return singleOpenStrategy;\n      case 'multiple':\n      default:\n        return multipleOpenStrategy;\n    }\n  });\n  var activated = useProxiedModel(props, 'activated', props.activated, function (v) {\n    return activeStrategy.value[\"in\"](v, children.value, parents.value);\n  }, function (v) {\n    return activeStrategy.value.out(v, children.value, parents.value);\n  });\n  var selected = useProxiedModel(props, 'selected', props.selected, function (v) {\n    return selectStrategy.value[\"in\"](v, children.value, parents.value);\n  }, function (v) {\n    return selectStrategy.value.out(v, children.value, parents.value);\n  });\n  onBeforeUnmount(function () {\n    isUnmounted = true;\n  });\n  function getPath(id) {\n    var path = [];\n    var parent = id;\n    while (parent != null) {\n      path.unshift(parent);\n      parent = parents.value.get(parent);\n    }\n    return path;\n  }\n  var vm = getCurrentInstance('nested');\n  var nodeIds = new Set();\n  var nested = {\n    id: shallowRef(),\n    root: {\n      opened: opened,\n      activatable: toRef(props, 'activatable'),\n      selectable: toRef(props, 'selectable'),\n      activated: activated,\n      selected: selected,\n      selectedValues: computed(function () {\n        var arr = [];\n        var _iterator = _createForOfIteratorHelper(selected.value.entries()),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n              key = _step$value[0],\n              value = _step$value[1];\n            if (value === 'on') arr.push(key);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        return arr;\n      }),\n      register: function register(id, parentId, isGroup) {\n        if (nodeIds.has(id)) {\n          var path = getPath(id).map(String).join(' -> ');\n          var newPath = getPath(parentId).concat(id).map(String).join(' -> ');\n          consoleError(\"Multiple nodes with the same ID\\n\\t\".concat(path, \"\\n\\t\").concat(newPath));\n          return;\n        } else {\n          nodeIds.add(id);\n        }\n        parentId && id !== parentId && parents.value.set(id, parentId);\n        isGroup && children.value.set(id, []);\n        if (parentId != null) {\n          children.value.set(parentId, [].concat(_toConsumableArray(children.value.get(parentId) || []), [id]));\n        }\n      },\n      unregister: function unregister(id) {\n        if (isUnmounted) return;\n        nodeIds[\"delete\"](id);\n        children.value[\"delete\"](id);\n        var parent = parents.value.get(id);\n        if (parent) {\n          var _children$value$get;\n          var list = (_children$value$get = children.value.get(parent)) !== null && _children$value$get !== void 0 ? _children$value$get : [];\n          children.value.set(parent, list.filter(function (child) {\n            return child !== id;\n          }));\n        }\n        parents.value[\"delete\"](id);\n      },\n      open: function open(id, value, event) {\n        vm.emit('click:open', {\n          id: id,\n          value: value,\n          path: getPath(id),\n          event: event\n        });\n        var newOpened = openStrategy.value.open({\n          id: id,\n          value: value,\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event: event\n        });\n        newOpened && (opened.value = newOpened);\n      },\n      openOnSelect: function openOnSelect(id, value, event) {\n        var newOpened = openStrategy.value.select({\n          id: id,\n          value: value,\n          selected: new Map(selected.value),\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event: event\n        });\n        newOpened && (opened.value = newOpened);\n      },\n      select: function select(id, value, event) {\n        vm.emit('click:select', {\n          id: id,\n          value: value,\n          path: getPath(id),\n          event: event\n        });\n        var newSelected = selectStrategy.value.select({\n          id: id,\n          value: value,\n          selected: new Map(selected.value),\n          children: children.value,\n          parents: parents.value,\n          event: event\n        });\n        newSelected && (selected.value = newSelected);\n        nested.root.openOnSelect(id, value, event);\n      },\n      activate: function activate(id, value, event) {\n        if (!props.activatable) {\n          return nested.root.select(id, true, event);\n        }\n        vm.emit('click:activate', {\n          id: id,\n          value: value,\n          path: getPath(id),\n          event: event\n        });\n        var newActivated = activeStrategy.value.activate({\n          id: id,\n          value: value,\n          activated: new Set(activated.value),\n          children: children.value,\n          parents: parents.value,\n          event: event\n        });\n        if (newActivated.size !== activated.value.size) {\n          activated.value = newActivated;\n        } else {\n          var _iterator2 = _createForOfIteratorHelper(newActivated),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _value = _step2.value;\n              if (!activated.value.has(_value)) {\n                activated.value = newActivated;\n                return;\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          var _iterator3 = _createForOfIteratorHelper(activated.value),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _value2 = _step3.value;\n              if (!newActivated.has(_value2)) {\n                activated.value = newActivated;\n                return;\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      },\n      children: children,\n      parents: parents,\n      getPath: getPath\n    }\n  };\n  provide(VNestedSymbol, nested);\n  return nested.root;\n};\nexport var useNestedItem = function useNestedItem(id, isGroup) {\n  var parent = inject(VNestedSymbol, emptyNested);\n  var uidSymbol = Symbol(getUid());\n  var computedId = computed(function () {\n    return id.value !== undefined ? id.value : uidSymbol;\n  });\n  var item = _objectSpread(_objectSpread({}, parent), {}, {\n    id: computedId,\n    open: function open(_open, e) {\n      return parent.root.open(computedId.value, _open, e);\n    },\n    openOnSelect: function openOnSelect(open, e) {\n      return parent.root.openOnSelect(computedId.value, open, e);\n    },\n    isOpen: computed(function () {\n      return parent.root.opened.value.has(computedId.value);\n    }),\n    parent: computed(function () {\n      return parent.root.parents.value.get(computedId.value);\n    }),\n    activate: function activate(activated, e) {\n      return parent.root.activate(computedId.value, activated, e);\n    },\n    isActivated: computed(function () {\n      return parent.root.activated.value.has(toRaw(computedId.value));\n    }),\n    select: function select(selected, e) {\n      return parent.root.select(computedId.value, selected, e);\n    },\n    isSelected: computed(function () {\n      return parent.root.selected.value.get(toRaw(computedId.value)) === 'on';\n    }),\n    isIndeterminate: computed(function () {\n      return parent.root.selected.value.get(toRaw(computedId.value)) === 'indeterminate';\n    }),\n    isLeaf: computed(function () {\n      return !parent.root.children.value.get(computedId.value);\n    }),\n    isGroupActivator: parent.isGroupActivator\n  });\n  onBeforeMount(function () {\n    !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup);\n  });\n  onBeforeUnmount(function () {\n    !parent.isGroupActivator && parent.root.unregister(computedId.value);\n  });\n  isGroup && provide(VNestedSymbol, item);\n  return item;\n};\nexport var useNestedGroupActivator = function useNestedGroupActivator() {\n  var parent = inject(VNestedSymbol, emptyNested);\n  provide(VNestedSymbol, _objectSpread(_objectSpread({}, parent), {}, {\n    isGroupActivator: true\n  }));\n};","map":{"version":3,"names":["useProxiedModel","computed","inject","onBeforeMount","onBeforeUnmount","provide","ref","shallowRef","toRaw","toRef","independentActiveStrategy","independentSingleActiveStrategy","leafActiveStrategy","leafSingleActiveStrategy","listOpenStrategy","multipleOpenStrategy","singleOpenStrategy","classicSelectStrategy","independentSelectStrategy","independentSingleSelectStrategy","leafSelectStrategy","leafSingleSelectStrategy","consoleError","getCurrentInstance","getUid","propsFactory","VNestedSymbol","Symbol","emptyNested","id","root","register","unregister","parents","Map","children","open","openOnSelect","activate","select","activatable","selectable","opened","Set","activated","selected","selectedValues","getPath","makeNestedProps","Boolean","activeStrategy","String","Function","Object","selectStrategy","openStrategy","mandatory","useNested","props","isUnmounted","v","_toConsumableArray","values","_typeof","value","out","path","parent","unshift","get","vm","nodeIds","nested","arr","_iterator","_createForOfIteratorHelper","entries","_step","s","n","done","_step$value","_slicedToArray","key","push","err","e","f","parentId","isGroup","has","map","join","newPath","concat","add","set","_children$value$get","list","filter","child","event","emit","newOpened","newSelected","newActivated","size","_iterator2","_step2","_iterator3","_step3","useNestedItem","uidSymbol","computedId","undefined","item","_objectSpread","isOpen","isActivated","isSelected","isIndeterminate","isLeaf","isGroupActivator","useNestedGroupActivator"],"sources":["../../../src/composables/nested/nested.ts"],"sourcesContent":["// Composables\nimport { useProxiedModel } from '@/composables/proxiedModel'\n\n// Utilities\nimport {\n  computed,\n  inject,\n  onBeforeMount,\n  onBeforeUnmount,\n  provide,\n  ref,\n  shallowRef,\n  toRaw,\n  toRef,\n} from 'vue'\nimport {\n  independentActiveStrategy,\n  independentSingleActiveStrategy,\n  leafActiveStrategy,\n  leafSingleActiveStrategy,\n} from './activeStrategies'\nimport { listOpenStrategy, multipleOpenStrategy, singleOpenStrategy } from './openStrategies'\nimport {\n  classicSelectStrategy,\n  independentSelectStrategy,\n  independentSingleSelectStrategy,\n  leafSelectStrategy,\n  leafSingleSelectStrategy,\n} from './selectStrategies'\nimport { consoleError, getCurrentInstance, getUid, propsFactory } from '@/util'\n\n// Types\nimport type { InjectionKey, PropType, Ref } from 'vue'\nimport type { ActiveStrategy } from './activeStrategies'\nimport type { OpenStrategy } from './openStrategies'\nimport type { SelectStrategy } from './selectStrategies'\nimport type { EventProp } from '@/util'\n\nexport type ActiveStrategyProp =\n  | 'single-leaf'\n  | 'leaf'\n  | 'independent'\n  | 'single-independent'\n  | ActiveStrategy\n  | ((mandatory: boolean) => ActiveStrategy)\nexport type SelectStrategyProp =\n  | 'single-leaf'\n  | 'leaf'\n  | 'independent'\n  | 'single-independent'\n  | 'classic'\n  | SelectStrategy\n  | ((mandatory: boolean) => SelectStrategy)\nexport type OpenStrategyProp = 'single' | 'multiple' | 'list' | OpenStrategy\n\nexport interface NestedProps {\n  activatable: boolean\n  selectable: boolean\n  activeStrategy: ActiveStrategyProp | undefined\n  selectStrategy: SelectStrategyProp | undefined\n  openStrategy: OpenStrategyProp | undefined\n  activated: any\n  selected: any\n  opened: any\n  mandatory: boolean\n  'onUpdate:activated': EventProp<[any]> | undefined\n  'onUpdate:selected': EventProp<[any]> | undefined\n  'onUpdate:opened': EventProp<[any]> | undefined\n}\n\ntype NestedProvide = {\n  id: Ref<unknown>\n  isGroupActivator?: boolean\n  root: {\n    children: Ref<Map<unknown, unknown[]>>\n    parents: Ref<Map<unknown, unknown>>\n    activatable: Ref<boolean>\n    selectable: Ref<boolean>\n    opened: Ref<Set<unknown>>\n    activated: Ref<Set<unknown>>\n    selected: Ref<Map<unknown, 'on' | 'off' | 'indeterminate'>>\n    selectedValues: Ref<unknown[]>\n    register: (id: unknown, parentId: unknown, isGroup?: boolean) => void\n    unregister: (id: unknown) => void\n    open: (id: unknown, value: boolean, event?: Event) => void\n    activate: (id: unknown, value: boolean, event?: Event) => void\n    select: (id: unknown, value: boolean, event?: Event) => void\n    openOnSelect: (id: unknown, value: boolean, event?: Event) => void\n    getPath: (id: unknown) => unknown[]\n  }\n}\n\nexport const VNestedSymbol: InjectionKey<NestedProvide> = Symbol.for('vuetify:nested')\n\nexport const emptyNested: NestedProvide = {\n  id: shallowRef(),\n  root: {\n    register: () => null,\n    unregister: () => null,\n    parents: ref(new Map()),\n    children: ref(new Map()),\n    open: () => null,\n    openOnSelect: () => null,\n    activate: () => null,\n    select: () => null,\n    activatable: ref(false),\n    selectable: ref(false),\n    opened: ref(new Set()),\n    activated: ref(new Set()),\n    selected: ref(new Map()),\n    selectedValues: ref([]),\n    getPath: () => [],\n  },\n}\n\nexport const makeNestedProps = propsFactory({\n  activatable: Boolean,\n  selectable: Boolean,\n  activeStrategy: [String, Function, Object] as PropType<ActiveStrategyProp>,\n  selectStrategy: [String, Function, Object] as PropType<SelectStrategyProp>,\n  openStrategy: [String, Object] as PropType<OpenStrategyProp>,\n  opened: null,\n  activated: null,\n  selected: null,\n  mandatory: Boolean,\n}, 'nested')\n\nexport const useNested = (props: NestedProps) => {\n  let isUnmounted = false\n  const children = ref(new Map<unknown, unknown[]>())\n  const parents = ref(new Map<unknown, unknown>())\n\n  const opened = useProxiedModel(props, 'opened', props.opened, v => new Set(v), v => [...v.values()])\n\n  const activeStrategy = computed(() => {\n    if (typeof props.activeStrategy === 'object') return props.activeStrategy\n    if (typeof props.activeStrategy === 'function') return props.activeStrategy(props.mandatory)\n\n    switch (props.activeStrategy) {\n      case 'leaf': return leafActiveStrategy(props.mandatory)\n      case 'single-leaf': return leafSingleActiveStrategy(props.mandatory)\n      case 'independent': return independentActiveStrategy(props.mandatory)\n      case 'single-independent':\n      default: return independentSingleActiveStrategy(props.mandatory)\n    }\n  })\n\n  const selectStrategy = computed(() => {\n    if (typeof props.selectStrategy === 'object') return props.selectStrategy\n    if (typeof props.selectStrategy === 'function') return props.selectStrategy(props.mandatory)\n\n    switch (props.selectStrategy) {\n      case 'single-leaf': return leafSingleSelectStrategy(props.mandatory)\n      case 'leaf': return leafSelectStrategy(props.mandatory)\n      case 'independent': return independentSelectStrategy(props.mandatory)\n      case 'single-independent': return independentSingleSelectStrategy(props.mandatory)\n      case 'classic':\n      default: return classicSelectStrategy(props.mandatory)\n    }\n  })\n\n  const openStrategy = computed(() => {\n    if (typeof props.openStrategy === 'object') return props.openStrategy\n\n    switch (props.openStrategy) {\n      case 'list': return listOpenStrategy\n      case 'single': return singleOpenStrategy\n      case 'multiple':\n      default: return multipleOpenStrategy\n    }\n  })\n\n  const activated = useProxiedModel(\n    props,\n    'activated',\n    props.activated,\n    v => activeStrategy.value.in(v, children.value, parents.value),\n    v => activeStrategy.value.out(v, children.value, parents.value),\n  )\n  const selected = useProxiedModel(\n    props,\n    'selected',\n    props.selected,\n    v => selectStrategy.value.in(v, children.value, parents.value),\n    v => selectStrategy.value.out(v, children.value, parents.value),\n  )\n\n  onBeforeUnmount(() => {\n    isUnmounted = true\n  })\n\n  function getPath (id: unknown) {\n    const path: unknown[] = []\n    let parent: unknown = id\n\n    while (parent != null) {\n      path.unshift(parent)\n      parent = parents.value.get(parent)\n    }\n\n    return path\n  }\n\n  const vm = getCurrentInstance('nested')\n\n  const nodeIds = new Set<unknown>()\n\n  const nested: NestedProvide = {\n    id: shallowRef(),\n    root: {\n      opened,\n      activatable: toRef(props, 'activatable'),\n      selectable: toRef(props, 'selectable'),\n      activated,\n      selected,\n      selectedValues: computed(() => {\n        const arr = []\n\n        for (const [key, value] of selected.value.entries()) {\n          if (value === 'on') arr.push(key)\n        }\n\n        return arr\n      }),\n      register: (id, parentId, isGroup) => {\n        if (nodeIds.has(id)) {\n          const path = getPath(id).map(String).join(' -> ')\n          const newPath = getPath(parentId).concat(id).map(String).join(' -> ')\n          consoleError(`Multiple nodes with the same ID\\n\\t${path}\\n\\t${newPath}`)\n          return\n        } else {\n          nodeIds.add(id)\n        }\n\n        parentId && id !== parentId && parents.value.set(id, parentId)\n\n        isGroup && children.value.set(id, [])\n\n        if (parentId != null) {\n          children.value.set(parentId, [...children.value.get(parentId) || [], id])\n        }\n      },\n      unregister: id => {\n        if (isUnmounted) return\n\n        nodeIds.delete(id)\n        children.value.delete(id)\n        const parent = parents.value.get(id)\n        if (parent) {\n          const list = children.value.get(parent) ?? []\n          children.value.set(parent, list.filter(child => child !== id))\n        }\n        parents.value.delete(id)\n      },\n      open: (id, value, event) => {\n        vm.emit('click:open', { id, value, path: getPath(id), event })\n\n        const newOpened = openStrategy.value.open({\n          id,\n          value,\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n\n        newOpened && (opened.value = newOpened)\n      },\n      openOnSelect: (id, value, event) => {\n        const newOpened = openStrategy.value.select({\n          id,\n          value,\n          selected: new Map(selected.value),\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n        newOpened && (opened.value = newOpened)\n      },\n      select: (id, value, event) => {\n        vm.emit('click:select', { id, value, path: getPath(id), event })\n\n        const newSelected = selectStrategy.value.select({\n          id,\n          value,\n          selected: new Map(selected.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n        newSelected && (selected.value = newSelected)\n\n        nested.root.openOnSelect(id, value, event)\n      },\n      activate: (id, value, event) => {\n        if (!props.activatable) {\n          return nested.root.select(id, true, event)\n        }\n\n        vm.emit('click:activate', { id, value, path: getPath(id), event })\n\n        const newActivated = activeStrategy.value.activate({\n          id,\n          value,\n          activated: new Set(activated.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n\n        if (newActivated.size !== activated.value.size) {\n          activated.value = newActivated\n        } else {\n          for (const value of newActivated) {\n            if (!activated.value.has(value)) {\n              activated.value = newActivated\n              return\n            }\n          }\n          for (const value of activated.value) {\n            if (!newActivated.has(value)) {\n              activated.value = newActivated\n              return\n            }\n          }\n        }\n      },\n      children,\n      parents,\n      getPath,\n    },\n  }\n\n  provide(VNestedSymbol, nested)\n\n  return nested.root\n}\n\nexport const useNestedItem = (id: Ref<unknown>, isGroup: boolean) => {\n  const parent = inject(VNestedSymbol, emptyNested)\n\n  const uidSymbol = Symbol(getUid())\n  const computedId = computed(() => id.value !== undefined ? id.value : uidSymbol)\n\n  const item = {\n    ...parent,\n    id: computedId,\n    open: (open: boolean, e: Event) => parent.root.open(computedId.value, open, e),\n    openOnSelect: (open: boolean, e?: Event) => parent.root.openOnSelect(computedId.value, open, e),\n    isOpen: computed(() => parent.root.opened.value.has(computedId.value)),\n    parent: computed(() => parent.root.parents.value.get(computedId.value)),\n    activate: (activated: boolean, e?: Event) => parent.root.activate(computedId.value, activated, e),\n    isActivated: computed(() => parent.root.activated.value.has(toRaw(computedId.value))),\n    select: (selected: boolean, e?: Event) => parent.root.select(computedId.value, selected, e),\n    isSelected: computed(() => parent.root.selected.value.get(toRaw(computedId.value)) === 'on'),\n    isIndeterminate: computed(() => parent.root.selected.value.get(toRaw(computedId.value)) === 'indeterminate'),\n    isLeaf: computed(() => !parent.root.children.value.get(computedId.value)),\n    isGroupActivator: parent.isGroupActivator,\n  }\n\n  onBeforeMount(() => {\n    !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup)\n  })\n\n  onBeforeUnmount(() => {\n    !parent.isGroupActivator && parent.root.unregister(computedId.value)\n  })\n\n  isGroup && provide(VNestedSymbol, item)\n\n  return item\n}\n\nexport const useNestedGroupActivator = () => {\n  const parent = inject(VNestedSymbol, emptyNested)\n\n  provide(VNestedSymbol, { ...parent, isGroupActivator: true })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}