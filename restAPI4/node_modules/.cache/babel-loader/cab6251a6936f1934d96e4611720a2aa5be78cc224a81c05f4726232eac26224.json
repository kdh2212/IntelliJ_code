{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/_dev3/restAPI4/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"C:/_dev3/restAPI4/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.array.find-index.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport { createVNode as _createVNode } from \"vue\";\n// Styles\nimport \"./VSlideGroup.css\";\n\n// Components\nimport { VFadeTransition } from \"../transitions/index.mjs\";\nimport { VIcon } from \"../VIcon/index.mjs\"; // Composables\nimport { makeComponentProps } from \"../../composables/component.mjs\";\nimport { makeDisplayProps, useDisplay } from \"../../composables/display.mjs\";\nimport { useGoTo } from \"../../composables/goto.mjs\";\nimport { makeGroupProps, useGroup } from \"../../composables/group.mjs\";\nimport { IconValue } from \"../../composables/icons.mjs\";\nimport { useRtl } from \"../../composables/locale.mjs\";\nimport { useResizeObserver } from \"../../composables/resizeObserver.mjs\";\nimport { makeTagProps } from \"../../composables/tag.mjs\"; // Utilities\nimport { computed, shallowRef, watch } from 'vue';\nimport { calculateCenteredTarget, calculateUpdatedTarget, getClientSize, getOffsetSize, getScrollPosition, getScrollSize } from \"./helpers.mjs\";\nimport { focusableChildren, genericComponent, IN_BROWSER, propsFactory, useRender } from \"../../util/index.mjs\"; // Types\nexport var VSlideGroupSymbol = Symbol[\"for\"]('vuetify:v-slide-group');\nexport var makeVSlideGroupProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({\n  centerActive: Boolean,\n  direction: {\n    type: String,\n    \"default\": 'horizontal'\n  },\n  symbol: {\n    type: null,\n    \"default\": VSlideGroupSymbol\n  },\n  nextIcon: {\n    type: IconValue,\n    \"default\": '$next'\n  },\n  prevIcon: {\n    type: IconValue,\n    \"default\": '$prev'\n  },\n  showArrows: {\n    type: [Boolean, String],\n    validator: function validator(v) {\n      return typeof v === 'boolean' || ['always', 'desktop', 'mobile'].includes(v);\n    }\n  }\n}, makeComponentProps()), makeDisplayProps({\n  mobile: null\n})), makeTagProps()), makeGroupProps({\n  selectedClass: 'v-slide-group-item--active'\n})), 'VSlideGroup');\nexport var VSlideGroup = genericComponent()({\n  name: 'VSlideGroup',\n  props: makeVSlideGroupProps(),\n  emits: {\n    'update:modelValue': function updateModelValue(value) {\n      return true;\n    }\n  },\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots;\n    var _useRtl = useRtl(),\n      isRtl = _useRtl.isRtl;\n    var _useDisplay = useDisplay(props),\n      displayClasses = _useDisplay.displayClasses,\n      mobile = _useDisplay.mobile;\n    var group = useGroup(props, props.symbol);\n    var isOverflowing = shallowRef(false);\n    var scrollOffset = shallowRef(0);\n    var containerSize = shallowRef(0);\n    var contentSize = shallowRef(0);\n    var isHorizontal = computed(function () {\n      return props.direction === 'horizontal';\n    });\n    var _useResizeObserver = useResizeObserver(),\n      containerRef = _useResizeObserver.resizeRef,\n      containerRect = _useResizeObserver.contentRect;\n    var _useResizeObserver2 = useResizeObserver(),\n      contentRef = _useResizeObserver2.resizeRef,\n      contentRect = _useResizeObserver2.contentRect;\n    var goTo = useGoTo();\n    var goToOptions = computed(function () {\n      return {\n        container: containerRef.el,\n        duration: 200,\n        easing: 'easeOutQuart'\n      };\n    });\n    var firstSelectedIndex = computed(function () {\n      if (!group.selected.value.length) return -1;\n      return group.items.value.findIndex(function (item) {\n        return item.id === group.selected.value[0];\n      });\n    });\n    var lastSelectedIndex = computed(function () {\n      if (!group.selected.value.length) return -1;\n      return group.items.value.findIndex(function (item) {\n        return item.id === group.selected.value[group.selected.value.length - 1];\n      });\n    });\n    if (IN_BROWSER) {\n      var frame = -1;\n      watch(function () {\n        return [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value];\n      }, function () {\n        cancelAnimationFrame(frame);\n        frame = requestAnimationFrame(function () {\n          if (containerRect.value && contentRect.value) {\n            var sizeProperty = isHorizontal.value ? 'width' : 'height';\n            containerSize.value = containerRect.value[sizeProperty];\n            contentSize.value = contentRect.value[sizeProperty];\n            isOverflowing.value = containerSize.value + 1 < contentSize.value;\n          }\n          if (firstSelectedIndex.value >= 0 && contentRef.el) {\n            // TODO: Is this too naive? Should we store element references in group composable?\n            var selectedElement = contentRef.el.children[lastSelectedIndex.value];\n            scrollToChildren(selectedElement, props.centerActive);\n          }\n        });\n      });\n    }\n    var isFocused = shallowRef(false);\n    function scrollToChildren(children, center) {\n      var target = 0;\n      if (center) {\n        target = calculateCenteredTarget({\n          containerElement: containerRef.el,\n          isHorizontal: isHorizontal.value,\n          selectedElement: children\n        });\n      } else {\n        target = calculateUpdatedTarget({\n          containerElement: containerRef.el,\n          isHorizontal: isHorizontal.value,\n          isRtl: isRtl.value,\n          selectedElement: children\n        });\n      }\n      scrollToPosition(target);\n    }\n    function scrollToPosition(newPosition) {\n      if (!IN_BROWSER || !containerRef.el) return;\n      var offsetSize = getOffsetSize(isHorizontal.value, containerRef.el);\n      var scrollPosition = getScrollPosition(isHorizontal.value, isRtl.value, containerRef.el);\n      var scrollSize = getScrollSize(isHorizontal.value, containerRef.el);\n      if (scrollSize <= offsetSize ||\n      // Prevent scrolling by only a couple of pixels, which doesn't look smooth\n      Math.abs(newPosition - scrollPosition) < 16) return;\n      if (isHorizontal.value && isRtl.value && containerRef.el) {\n        var _containerRef$el = containerRef.el,\n          scrollWidth = _containerRef$el.scrollWidth,\n          containerWidth = _containerRef$el.offsetWidth;\n        newPosition = scrollWidth - containerWidth - newPosition;\n      }\n      if (isHorizontal.value) {\n        goTo.horizontal(newPosition, goToOptions.value);\n      } else {\n        goTo(newPosition, goToOptions.value);\n      }\n    }\n    function onScroll(e) {\n      var _e$target = e.target,\n        scrollTop = _e$target.scrollTop,\n        scrollLeft = _e$target.scrollLeft;\n      scrollOffset.value = isHorizontal.value ? scrollLeft : scrollTop;\n    }\n    function onFocusin(e) {\n      isFocused.value = true;\n      if (!isOverflowing.value || !contentRef.el) return;\n\n      // Focused element is likely to be the root of an item, so a\n      // breadth-first search will probably find it in the first iteration\n      var _iterator = _createForOfIteratorHelper(e.composedPath()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var el = _step.value;\n          var _iterator2 = _createForOfIteratorHelper(contentRef.el.children),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var item = _step2.value;\n              if (item === el) {\n                scrollToChildren(item);\n                return;\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    function onFocusout(e) {\n      isFocused.value = false;\n    }\n\n    // Affix clicks produce onFocus that we have to ignore to avoid extra scrollToChildren\n    var ignoreFocusEvent = false;\n    function onFocus(e) {\n      var _contentRef$el;\n      if (!ignoreFocusEvent && !isFocused.value && !(e.relatedTarget && (_contentRef$el = contentRef.el) !== null && _contentRef$el !== void 0 && _contentRef$el.contains(e.relatedTarget))) focus();\n      ignoreFocusEvent = false;\n    }\n    function onFocusAffixes() {\n      ignoreFocusEvent = true;\n    }\n    function onKeydown(e) {\n      if (!contentRef.el) return;\n      function toFocus(location) {\n        e.preventDefault();\n        focus(location);\n      }\n      if (isHorizontal.value) {\n        if (e.key === 'ArrowRight') {\n          toFocus(isRtl.value ? 'prev' : 'next');\n        } else if (e.key === 'ArrowLeft') {\n          toFocus(isRtl.value ? 'next' : 'prev');\n        }\n      } else {\n        if (e.key === 'ArrowDown') {\n          toFocus('next');\n        } else if (e.key === 'ArrowUp') {\n          toFocus('prev');\n        }\n      }\n      if (e.key === 'Home') {\n        toFocus('first');\n      } else if (e.key === 'End') {\n        toFocus('last');\n      }\n    }\n    function getSiblingElement(el, location) {\n      if (!el) return undefined;\n      var sibling = el;\n      do {\n        var _sibling, _sibling2;\n        sibling = (_sibling = sibling) === null || _sibling === void 0 ? void 0 : _sibling[location === 'next' ? 'nextElementSibling' : 'previousElementSibling'];\n      } while ((_sibling2 = sibling) !== null && _sibling2 !== void 0 && _sibling2.hasAttribute('disabled'));\n      return sibling;\n    }\n    function focus(location) {\n      if (!contentRef.el) return;\n      var el;\n      if (!location) {\n        var focusable = focusableChildren(contentRef.el);\n        el = focusable[0];\n      } else if (location === 'next') {\n        el = getSiblingElement(contentRef.el.querySelector(':focus'), location);\n        if (!el) return focus('first');\n      } else if (location === 'prev') {\n        el = getSiblingElement(contentRef.el.querySelector(':focus'), location);\n        if (!el) return focus('last');\n      } else if (location === 'first') {\n        var _el;\n        el = contentRef.el.firstElementChild;\n        if ((_el = el) !== null && _el !== void 0 && _el.hasAttribute('disabled')) el = getSiblingElement(el, 'next');\n      } else if (location === 'last') {\n        var _el2;\n        el = contentRef.el.lastElementChild;\n        if ((_el2 = el) !== null && _el2 !== void 0 && _el2.hasAttribute('disabled')) el = getSiblingElement(el, 'prev');\n      }\n      if (el) {\n        el.focus({\n          preventScroll: true\n        });\n      }\n    }\n    function scrollTo(location) {\n      var direction = isHorizontal.value && isRtl.value ? -1 : 1;\n      var offsetStep = (location === 'prev' ? -direction : direction) * containerSize.value;\n      var newPosition = scrollOffset.value + offsetStep;\n\n      // TODO: improve it\n      if (isHorizontal.value && isRtl.value && containerRef.el) {\n        var _containerRef$el2 = containerRef.el,\n          scrollWidth = _containerRef$el2.scrollWidth,\n          containerWidth = _containerRef$el2.offsetWidth;\n        newPosition += scrollWidth - containerWidth;\n      }\n      scrollToPosition(newPosition);\n    }\n    var slotProps = computed(function () {\n      return {\n        next: group.next,\n        prev: group.prev,\n        select: group.select,\n        isSelected: group.isSelected\n      };\n    });\n    var hasAffixes = computed(function () {\n      switch (props.showArrows) {\n        // Always show arrows on desktop & mobile\n        case 'always':\n          return true;\n\n        // Always show arrows on desktop\n        case 'desktop':\n          return !mobile.value;\n\n        // Show arrows on mobile when overflowing.\n        // This matches the default 2.2 behavior\n        case true:\n          return isOverflowing.value || Math.abs(scrollOffset.value) > 0;\n\n        // Always show on mobile\n        case 'mobile':\n          return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;\n\n        // https://material.io/components/tabs#scrollable-tabs\n        // Always show arrows when\n        // overflowed on desktop\n        default:\n          return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);\n      }\n    });\n    var hasPrev = computed(function () {\n      // 1 pixel in reserve, may be lost after rounding\n      return Math.abs(scrollOffset.value) > 1;\n    });\n    var hasNext = computed(function () {\n      if (!containerRef.value) return false;\n      var scrollSize = getScrollSize(isHorizontal.value, containerRef.el);\n      var clientSize = getClientSize(isHorizontal.value, containerRef.el);\n      var scrollSizeMax = scrollSize - clientSize;\n\n      // 1 pixel in reserve, may be lost after rounding\n      return scrollSizeMax - Math.abs(scrollOffset.value) > 1;\n    });\n    useRender(function () {\n      return _createVNode(props.tag, {\n        \"class\": ['v-slide-group', {\n          'v-slide-group--vertical': !isHorizontal.value,\n          'v-slide-group--has-affixes': hasAffixes.value,\n          'v-slide-group--is-overflowing': isOverflowing.value\n        }, displayClasses.value, props[\"class\"]],\n        \"style\": props.style,\n        \"tabindex\": isFocused.value || group.selected.value.length ? -1 : 0,\n        \"onFocus\": onFocus\n      }, {\n        \"default\": function _default() {\n          var _slots$prev, _slots$prev2, _slots$default, _slots$next, _slots$next2;\n          return [hasAffixes.value && _createVNode(\"div\", {\n            \"key\": \"prev\",\n            \"class\": ['v-slide-group__prev', {\n              'v-slide-group__prev--disabled': !hasPrev.value\n            }],\n            \"onMousedown\": onFocusAffixes,\n            \"onClick\": function onClick() {\n              return hasPrev.value && scrollTo('prev');\n            }\n          }, [(_slots$prev = (_slots$prev2 = slots.prev) === null || _slots$prev2 === void 0 ? void 0 : _slots$prev2.call(slots, slotProps.value)) !== null && _slots$prev !== void 0 ? _slots$prev : _createVNode(VFadeTransition, null, {\n            \"default\": function _default() {\n              return [_createVNode(VIcon, {\n                \"icon\": isRtl.value ? props.nextIcon : props.prevIcon\n              }, null)];\n            }\n          })]), _createVNode(\"div\", {\n            \"key\": \"container\",\n            \"ref\": containerRef,\n            \"class\": \"v-slide-group__container\",\n            \"onScroll\": onScroll\n          }, [_createVNode(\"div\", {\n            \"ref\": contentRef,\n            \"class\": \"v-slide-group__content\",\n            \"onFocusin\": onFocusin,\n            \"onFocusout\": onFocusout,\n            \"onKeydown\": onKeydown\n          }, [(_slots$default = slots[\"default\"]) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots, slotProps.value)])]), hasAffixes.value && _createVNode(\"div\", {\n            \"key\": \"next\",\n            \"class\": ['v-slide-group__next', {\n              'v-slide-group__next--disabled': !hasNext.value\n            }],\n            \"onMousedown\": onFocusAffixes,\n            \"onClick\": function onClick() {\n              return hasNext.value && scrollTo('next');\n            }\n          }, [(_slots$next = (_slots$next2 = slots.next) === null || _slots$next2 === void 0 ? void 0 : _slots$next2.call(slots, slotProps.value)) !== null && _slots$next !== void 0 ? _slots$next : _createVNode(VFadeTransition, null, {\n            \"default\": function _default() {\n              return [_createVNode(VIcon, {\n                \"icon\": isRtl.value ? props.prevIcon : props.nextIcon\n              }, null)];\n            }\n          })])];\n        }\n      });\n    });\n    return {\n      selected: group.selected,\n      scrollTo: scrollTo,\n      scrollOffset: scrollOffset,\n      focus: focus,\n      hasPrev: hasPrev,\n      hasNext: hasNext\n    };\n  }\n});","map":{"version":3,"names":["VFadeTransition","VIcon","makeComponentProps","makeDisplayProps","useDisplay","useGoTo","makeGroupProps","useGroup","IconValue","useRtl","useResizeObserver","makeTagProps","computed","shallowRef","watch","calculateCenteredTarget","calculateUpdatedTarget","getClientSize","getOffsetSize","getScrollPosition","getScrollSize","focusableChildren","genericComponent","IN_BROWSER","propsFactory","useRender","VSlideGroupSymbol","Symbol","makeVSlideGroupProps","_objectSpread","centerActive","Boolean","direction","type","String","symbol","nextIcon","prevIcon","showArrows","validator","v","includes","mobile","selectedClass","VSlideGroup","name","props","emits","updateModelValue","value","setup","_ref","slots","_useRtl","isRtl","_useDisplay","displayClasses","group","isOverflowing","scrollOffset","containerSize","contentSize","isHorizontal","_useResizeObserver","containerRef","resizeRef","containerRect","contentRect","_useResizeObserver2","contentRef","goTo","goToOptions","container","el","duration","easing","firstSelectedIndex","selected","length","items","findIndex","item","id","lastSelectedIndex","frame","cancelAnimationFrame","requestAnimationFrame","sizeProperty","selectedElement","children","scrollToChildren","isFocused","center","target","containerElement","scrollToPosition","newPosition","offsetSize","scrollPosition","scrollSize","Math","abs","_containerRef$el","scrollWidth","containerWidth","offsetWidth","horizontal","onScroll","e","_e$target","scrollTop","scrollLeft","onFocusin","_iterator","_createForOfIteratorHelper","composedPath","_step","s","n","done","_iterator2","_step2","err","f","onFocusout","ignoreFocusEvent","onFocus","_contentRef$el","relatedTarget","contains","focus","onFocusAffixes","onKeydown","toFocus","location","preventDefault","key","getSiblingElement","undefined","sibling","_sibling","_sibling2","hasAttribute","focusable","querySelector","_el","firstElementChild","_el2","lastElementChild","preventScroll","scrollTo","offsetStep","_containerRef$el2","slotProps","next","prev","select","isSelected","hasAffixes","hasPrev","hasNext","clientSize","scrollSizeMax","_createVNode","tag","style","default","_slots$prev","_slots$prev2","_slots$default","_slots$next","_slots$next2","onClick","call"],"sources":["../../../src/components/VSlideGroup/VSlideGroup.tsx"],"sourcesContent":["// Styles\nimport './VSlideGroup.sass'\n\n// Components\nimport { VFadeTransition } from '@/components/transitions'\nimport { VIcon } from '@/components/VIcon'\n\n// Composables\nimport { makeComponentProps } from '@/composables/component'\nimport { makeDisplayProps, useDisplay } from '@/composables/display'\nimport { useGoTo } from '@/composables/goto'\nimport { makeGroupProps, useGroup } from '@/composables/group'\nimport { IconValue } from '@/composables/icons'\nimport { useRtl } from '@/composables/locale'\nimport { useResizeObserver } from '@/composables/resizeObserver'\nimport { makeTagProps } from '@/composables/tag'\n\n// Utilities\nimport { computed, shallowRef, watch } from 'vue'\nimport {\n  calculateCenteredTarget,\n  calculateUpdatedTarget,\n  getClientSize,\n  getOffsetSize,\n  getScrollPosition,\n  getScrollSize,\n} from './helpers'\nimport { focusableChildren, genericComponent, IN_BROWSER, propsFactory, useRender } from '@/util'\n\n// Types\nimport type { InjectionKey, PropType } from 'vue'\nimport type { GoToOptions } from '@/composables/goto'\nimport type { GroupProvide } from '@/composables/group'\nimport type { GenericProps } from '@/util'\n\nexport const VSlideGroupSymbol: InjectionKey<GroupProvide> = Symbol.for('vuetify:v-slide-group')\n\ninterface SlideGroupSlot {\n  next: GroupProvide['next']\n  prev: GroupProvide['prev']\n  select: GroupProvide['select']\n  isSelected: GroupProvide['isSelected']\n}\n\ntype VSlideGroupSlots = {\n  default: SlideGroupSlot\n  prev: SlideGroupSlot\n  next: SlideGroupSlot\n}\n\nexport const makeVSlideGroupProps = propsFactory({\n  centerActive: Boolean,\n  direction: {\n    type: String as PropType<'horizontal' | 'vertical'>,\n    default: 'horizontal',\n  },\n  symbol: {\n    type: null,\n    default: VSlideGroupSymbol,\n  },\n  nextIcon: {\n    type: IconValue,\n    default: '$next',\n  },\n  prevIcon: {\n    type: IconValue,\n    default: '$prev',\n  },\n  showArrows: {\n    type: [Boolean, String],\n    validator: (v: any) => (\n      typeof v === 'boolean' || [\n        'always',\n        'desktop',\n        'mobile',\n      ].includes(v)\n    ),\n  },\n\n  ...makeComponentProps(),\n  ...makeDisplayProps({ mobile: null }),\n  ...makeTagProps(),\n  ...makeGroupProps({\n    selectedClass: 'v-slide-group-item--active',\n  }),\n}, 'VSlideGroup')\n\nexport const VSlideGroup = genericComponent<new <T>(\n  props: {\n    modelValue?: T\n    'onUpdate:modelValue'?: (value: T) => void\n  },\n  slots: VSlideGroupSlots,\n) => GenericProps<typeof props, typeof slots>>()({\n  name: 'VSlideGroup',\n\n  props: makeVSlideGroupProps(),\n\n  emits: {\n    'update:modelValue': (value: any) => true,\n  },\n\n  setup (props, { slots }) {\n    const { isRtl } = useRtl()\n    const { displayClasses, mobile } = useDisplay(props)\n    const group = useGroup(props, props.symbol)\n    const isOverflowing = shallowRef(false)\n    const scrollOffset = shallowRef(0)\n    const containerSize = shallowRef(0)\n    const contentSize = shallowRef(0)\n    const isHorizontal = computed(() => props.direction === 'horizontal')\n\n    const { resizeRef: containerRef, contentRect: containerRect } = useResizeObserver()\n    const { resizeRef: contentRef, contentRect } = useResizeObserver()\n\n    const goTo = useGoTo()\n    const goToOptions = computed<Partial<GoToOptions>>(() => {\n      return {\n        container: containerRef.el,\n        duration: 200,\n        easing: 'easeOutQuart',\n      }\n    })\n\n    const firstSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1\n\n      return group.items.value.findIndex(item => item.id === group.selected.value[0])\n    })\n\n    const lastSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1\n\n      return group.items.value.findIndex(item => item.id === group.selected.value[group.selected.value.length - 1])\n    })\n\n    if (IN_BROWSER) {\n      let frame = -1\n      watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {\n        cancelAnimationFrame(frame)\n        frame = requestAnimationFrame(() => {\n          if (containerRect.value && contentRect.value) {\n            const sizeProperty = isHorizontal.value ? 'width' : 'height'\n\n            containerSize.value = containerRect.value[sizeProperty]\n            contentSize.value = contentRect.value[sizeProperty]\n\n            isOverflowing.value = containerSize.value + 1 < contentSize.value\n          }\n\n          if (firstSelectedIndex.value >= 0 && contentRef.el) {\n            // TODO: Is this too naive? Should we store element references in group composable?\n            const selectedElement = contentRef.el.children[lastSelectedIndex.value] as HTMLElement\n\n            scrollToChildren(selectedElement, props.centerActive)\n          }\n        })\n      })\n    }\n\n    const isFocused = shallowRef(false)\n\n    function scrollToChildren (children: HTMLElement, center?: boolean) {\n      let target = 0\n\n      if (center) {\n        target = calculateCenteredTarget({\n          containerElement: containerRef.el!,\n          isHorizontal: isHorizontal.value,\n          selectedElement: children,\n        })\n      } else {\n        target = calculateUpdatedTarget({\n          containerElement: containerRef.el!,\n          isHorizontal: isHorizontal.value,\n          isRtl: isRtl.value,\n          selectedElement: children,\n        })\n      }\n\n      scrollToPosition(target)\n    }\n\n    function scrollToPosition (newPosition: number) {\n      if (!IN_BROWSER || !containerRef.el) return\n\n      const offsetSize = getOffsetSize(isHorizontal.value, containerRef.el)\n      const scrollPosition = getScrollPosition(isHorizontal.value, isRtl.value, containerRef.el)\n      const scrollSize = getScrollSize(isHorizontal.value, containerRef.el)\n\n      if (\n        scrollSize <= offsetSize ||\n        // Prevent scrolling by only a couple of pixels, which doesn't look smooth\n        Math.abs(newPosition - scrollPosition) < 16\n      ) return\n\n      if (isHorizontal.value && isRtl.value && containerRef.el) {\n        const { scrollWidth, offsetWidth: containerWidth } = containerRef.el!\n\n        newPosition = (scrollWidth - containerWidth) - newPosition\n      }\n\n      if (isHorizontal.value) {\n        goTo.horizontal(newPosition, goToOptions.value)\n      } else {\n        goTo(newPosition, goToOptions.value)\n      }\n    }\n\n    function onScroll (e: Event) {\n      const { scrollTop, scrollLeft } = e.target as HTMLElement\n\n      scrollOffset.value = isHorizontal.value ? scrollLeft : scrollTop\n    }\n\n    function onFocusin (e: FocusEvent) {\n      isFocused.value = true\n\n      if (!isOverflowing.value || !contentRef.el) return\n\n      // Focused element is likely to be the root of an item, so a\n      // breadth-first search will probably find it in the first iteration\n      for (const el of e.composedPath()) {\n        for (const item of contentRef.el.children) {\n          if (item === el) {\n            scrollToChildren(item as HTMLElement)\n            return\n          }\n        }\n      }\n    }\n\n    function onFocusout (e: FocusEvent) {\n      isFocused.value = false\n    }\n\n    // Affix clicks produce onFocus that we have to ignore to avoid extra scrollToChildren\n    let ignoreFocusEvent = false\n    function onFocus (e: FocusEvent) {\n      if (\n        !ignoreFocusEvent &&\n        !isFocused.value &&\n        !(e.relatedTarget && contentRef.el?.contains(e.relatedTarget as Node))\n      ) focus()\n\n      ignoreFocusEvent = false\n    }\n\n    function onFocusAffixes () {\n      ignoreFocusEvent = true\n    }\n\n    function onKeydown (e: KeyboardEvent) {\n      if (!contentRef.el) return\n\n      function toFocus (location: Parameters<typeof focus>[0]) {\n        e.preventDefault()\n        focus(location)\n      }\n\n      if (isHorizontal.value) {\n        if (e.key === 'ArrowRight') {\n          toFocus(isRtl.value ? 'prev' : 'next')\n        } else if (e.key === 'ArrowLeft') {\n          toFocus(isRtl.value ? 'next' : 'prev')\n        }\n      } else {\n        if (e.key === 'ArrowDown') {\n          toFocus('next')\n        } else if (e.key === 'ArrowUp') {\n          toFocus('prev')\n        }\n      }\n\n      if (e.key === 'Home') {\n        toFocus('first')\n      } else if (e.key === 'End') {\n        toFocus('last')\n      }\n    }\n\n    function getSiblingElement (el: HTMLElement | null, location: 'next' | 'prev') {\n      if (!el) return undefined\n      let sibling: HTMLElement | null = el\n      do {\n        sibling = sibling?.[location === 'next' ? 'nextElementSibling' : 'previousElementSibling'] as HTMLElement | null\n      } while (sibling?.hasAttribute('disabled'))\n      return sibling\n    }\n\n    function focus (location?: 'next' | 'prev' | 'first' | 'last') {\n      if (!contentRef.el) return\n\n      let el: HTMLElement | null | undefined\n\n      if (!location) {\n        const focusable = focusableChildren(contentRef.el)\n        el = focusable[0]\n      } else if (location === 'next') {\n        el = getSiblingElement(contentRef.el.querySelector(':focus'), location)\n\n        if (!el) return focus('first')\n      } else if (location === 'prev') {\n        el = getSiblingElement(contentRef.el.querySelector(':focus'), location)\n\n        if (!el) return focus('last')\n      } else if (location === 'first') {\n        el = (contentRef.el.firstElementChild as HTMLElement)\n\n        if (el?.hasAttribute('disabled')) el = getSiblingElement(el, 'next')\n      } else if (location === 'last') {\n        el = (contentRef.el.lastElementChild as HTMLElement)\n\n        if (el?.hasAttribute('disabled')) el = getSiblingElement(el, 'prev')\n      }\n\n      if (el) {\n        el.focus({ preventScroll: true })\n      }\n    }\n\n    function scrollTo (location: 'prev' | 'next') {\n      const direction = isHorizontal.value && isRtl.value ? -1 : 1\n\n      const offsetStep = (location === 'prev' ? -direction : direction) * containerSize.value\n\n      let newPosition = scrollOffset.value + offsetStep\n\n      // TODO: improve it\n      if (isHorizontal.value && isRtl.value && containerRef.el) {\n        const { scrollWidth, offsetWidth: containerWidth } = containerRef.el!\n\n        newPosition += scrollWidth - containerWidth\n      }\n\n      scrollToPosition(newPosition)\n    }\n\n    const slotProps = computed(() => ({\n      next: group.next,\n      prev: group.prev,\n      select: group.select,\n      isSelected: group.isSelected,\n    }))\n\n    const hasAffixes = computed(() => {\n      switch (props.showArrows) {\n        // Always show arrows on desktop & mobile\n        case 'always': return true\n\n        // Always show arrows on desktop\n        case 'desktop': return !mobile.value\n\n        // Show arrows on mobile when overflowing.\n        // This matches the default 2.2 behavior\n        case true: return isOverflowing.value || Math.abs(scrollOffset.value) > 0\n\n        // Always show on mobile\n        case 'mobile': return (\n          mobile.value ||\n          (isOverflowing.value || Math.abs(scrollOffset.value) > 0)\n        )\n\n        // https://material.io/components/tabs#scrollable-tabs\n        // Always show arrows when\n        // overflowed on desktop\n        default: return (\n          !mobile.value &&\n          (isOverflowing.value || Math.abs(scrollOffset.value) > 0)\n        )\n      }\n    })\n\n    const hasPrev = computed(() => {\n      // 1 pixel in reserve, may be lost after rounding\n      return Math.abs(scrollOffset.value) > 1\n    })\n\n    const hasNext = computed(() => {\n      if (!containerRef.value) return false\n\n      const scrollSize = getScrollSize(isHorizontal.value, containerRef.el)\n      const clientSize = getClientSize(isHorizontal.value, containerRef.el)\n\n      const scrollSizeMax = scrollSize - clientSize\n\n      // 1 pixel in reserve, may be lost after rounding\n      return scrollSizeMax - Math.abs(scrollOffset.value) > 1\n    })\n\n    useRender(() => (\n      <props.tag\n        class={[\n          'v-slide-group',\n          {\n            'v-slide-group--vertical': !isHorizontal.value,\n            'v-slide-group--has-affixes': hasAffixes.value,\n            'v-slide-group--is-overflowing': isOverflowing.value,\n          },\n          displayClasses.value,\n          props.class,\n        ]}\n        style={ props.style }\n        tabindex={ (isFocused.value || group.selected.value.length) ? -1 : 0 }\n        onFocus={ onFocus }\n      >\n        { hasAffixes.value && (\n          <div\n            key=\"prev\"\n            class={[\n              'v-slide-group__prev',\n              { 'v-slide-group__prev--disabled': !hasPrev.value },\n            ]}\n            onMousedown={ onFocusAffixes }\n            onClick={ () => hasPrev.value && scrollTo('prev') }\n          >\n            { slots.prev?.(slotProps.value) ?? (\n              <VFadeTransition>\n                <VIcon icon={ isRtl.value ? props.nextIcon : props.prevIcon }></VIcon>\n              </VFadeTransition>\n            )}\n          </div>\n        )}\n\n        <div\n          key=\"container\"\n          ref={ containerRef }\n          class=\"v-slide-group__container\"\n          onScroll={ onScroll }\n        >\n          <div\n            ref={ contentRef }\n            class=\"v-slide-group__content\"\n            onFocusin={ onFocusin }\n            onFocusout={ onFocusout }\n            onKeydown={ onKeydown }\n          >\n            { slots.default?.(slotProps.value) }\n          </div>\n        </div>\n\n        { hasAffixes.value && (\n          <div\n            key=\"next\"\n            class={[\n              'v-slide-group__next',\n              { 'v-slide-group__next--disabled': !hasNext.value },\n            ]}\n            onMousedown={ onFocusAffixes }\n            onClick={ () => hasNext.value && scrollTo('next') }\n          >\n            { slots.next?.(slotProps.value) ?? (\n              <VFadeTransition>\n                <VIcon icon={ isRtl.value ? props.prevIcon : props.nextIcon }></VIcon>\n              </VFadeTransition>\n            )}\n          </div>\n        )}\n      </props.tag>\n    ))\n\n    return {\n      selected: group.selected,\n      scrollTo,\n      scrollOffset,\n      focus,\n      hasPrev,\n      hasNext,\n    }\n  },\n})\n\nexport type VSlideGroup = InstanceType<typeof VSlideGroup>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}