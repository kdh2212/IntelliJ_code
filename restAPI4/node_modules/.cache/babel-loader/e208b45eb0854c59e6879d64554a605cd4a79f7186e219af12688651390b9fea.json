{"ast":null,"code":"import _regeneratorRuntime from \"C:/_dev3/restAPI4/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/_dev3/restAPI4/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _typeof from \"C:/_dev3/restAPI4/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _toConsumableArray from \"C:/_dev3/restAPI4/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"C:/_dev3/restAPI4/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.parse-int.js\";\n// Utilities\nimport { computed, nextTick, ref, watch, createVNode as _createVNode } from 'vue';\nimport { makeLineProps } from \"./util/line.mjs\";\nimport { genPath as _genPath } from \"./util/path.mjs\";\nimport { genericComponent, getPropertyFromItem, getUid, propsFactory, useRender } from \"../../util/index.mjs\"; // Types\nexport var makeVTrendlineProps = propsFactory(_objectSpread({\n  fill: Boolean\n}, makeLineProps()), 'VTrendline');\nexport var VTrendline = genericComponent()({\n  name: 'VTrendline',\n  props: makeVTrendlineProps(),\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots;\n    var uid = getUid();\n    var id = computed(function () {\n      return props.id || \"trendline-\".concat(uid);\n    });\n    var autoDrawDuration = computed(function () {\n      return Number(props.autoDrawDuration) || (props.fill ? 500 : 2000);\n    });\n    var lastLength = ref(0);\n    var path = ref(null);\n    function genPoints(values, boundary) {\n      var minX = boundary.minX,\n        maxX = boundary.maxX,\n        minY = boundary.minY,\n        maxY = boundary.maxY;\n      var totalValues = values.length;\n      var maxValue = props.max != null ? Number(props.max) : Math.max.apply(Math, _toConsumableArray(values));\n      var minValue = props.min != null ? Number(props.min) : Math.min.apply(Math, _toConsumableArray(values));\n      var gridX = (maxX - minX) / (totalValues - 1);\n      var gridY = (maxY - minY) / (maxValue - minValue || 1);\n      return values.map(function (value, index) {\n        return {\n          x: minX + index * gridX,\n          y: maxY - (value - minValue) * gridY,\n          value: value\n        };\n      });\n    }\n    var hasLabels = computed(function () {\n      return Boolean(props.showLabels || props.labels.length > 0 || !!(slots !== null && slots !== void 0 && slots.label));\n    });\n    var lineWidth = computed(function () {\n      return parseFloat(props.lineWidth) || 4;\n    });\n    var totalWidth = computed(function () {\n      return Number(props.width);\n    });\n    var boundary = computed(function () {\n      var padding = Number(props.padding);\n      return {\n        minX: padding,\n        maxX: totalWidth.value - padding,\n        minY: padding,\n        maxY: parseInt(props.height, 10) - padding\n      };\n    });\n    var items = computed(function () {\n      return props.modelValue.map(function (item) {\n        return getPropertyFromItem(item, props.itemValue, item);\n      });\n    });\n    var parsedLabels = computed(function () {\n      var labels = [];\n      var points = genPoints(items.value, boundary.value);\n      var len = points.length;\n      for (var i = 0; labels.length < len; i++) {\n        var item = points[i];\n        var value = props.labels[i];\n        if (!value) {\n          value = _typeof(item) === 'object' ? item.value : item;\n        }\n        labels.push({\n          x: item.x,\n          value: String(value)\n        });\n      }\n      return labels;\n    });\n    watch(function () {\n      return props.modelValue;\n    }, /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var pathRef, length;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return nextTick();\n          case 2:\n            if (!(!props.autoDraw || !path.value)) {\n              _context.next = 4;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 4:\n            pathRef = path.value;\n            length = pathRef.getTotalLength();\n            if (!props.fill) {\n              // Initial setup to \"hide\" the line by using the stroke dash array\n              pathRef.style.strokeDasharray = \"\".concat(length);\n              pathRef.style.strokeDashoffset = \"\".concat(length);\n\n              // Force reflow to ensure the transition starts from this state\n              pathRef.getBoundingClientRect();\n\n              // Animate the stroke dash offset to \"draw\" the line\n              pathRef.style.transition = \"stroke-dashoffset \".concat(autoDrawDuration.value, \"ms \").concat(props.autoDrawEasing);\n              pathRef.style.strokeDashoffset = '0';\n            } else {\n              // Your existing logic for filled paths remains the same\n              pathRef.style.transformOrigin = 'bottom center';\n              pathRef.style.transition = 'none';\n              pathRef.style.transform = \"scaleY(0)\";\n              pathRef.getBoundingClientRect();\n              pathRef.style.transition = \"transform \".concat(autoDrawDuration.value, \"ms \").concat(props.autoDrawEasing);\n              pathRef.style.transform = \"scaleY(1)\";\n            }\n            lastLength.value = length;\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    })), {\n      immediate: true\n    });\n    function genPath(fill) {\n      var smoothValue = typeof props.smooth === 'boolean' ? props.smooth ? 8 : 0 : Number(props.smooth);\n      return _genPath(genPoints(items.value, boundary.value), smoothValue, fill, parseInt(props.height, 10));\n    }\n    useRender(function () {\n      var _parseFloat, _props$color, _props$gradient;\n      var gradientData = !props.gradient.slice().length ? [''] : props.gradient.slice().reverse();\n      return _createVNode(\"svg\", {\n        \"display\": \"block\",\n        \"stroke-width\": (_parseFloat = parseFloat(props.lineWidth)) !== null && _parseFloat !== void 0 ? _parseFloat : 4\n      }, [_createVNode(\"defs\", null, [_createVNode(\"linearGradient\", {\n        \"id\": id.value,\n        \"gradientUnits\": \"userSpaceOnUse\",\n        \"x1\": props.gradientDirection === 'left' ? '100%' : '0',\n        \"y1\": props.gradientDirection === 'top' ? '100%' : '0',\n        \"x2\": props.gradientDirection === 'right' ? '100%' : '0',\n        \"y2\": props.gradientDirection === 'bottom' ? '100%' : '0'\n      }, [gradientData.map(function (color, index) {\n        return _createVNode(\"stop\", {\n          \"offset\": index / Math.max(gradientData.length - 1, 1),\n          \"stop-color\": color || 'currentColor'\n        }, null);\n      })])]), hasLabels.value && _createVNode(\"g\", {\n        \"key\": \"labels\",\n        \"style\": {\n          textAnchor: 'middle',\n          dominantBaseline: 'mathematical',\n          fill: 'currentColor'\n        }\n      }, [parsedLabels.value.map(function (item, i) {\n        var _slots$label, _slots$label2;\n        return _createVNode(\"text\", {\n          \"x\": item.x + lineWidth.value / 2 + lineWidth.value / 2,\n          \"y\": parseInt(props.height, 10) - 4 + (parseInt(props.labelSize, 10) || 7 * 0.75),\n          \"font-size\": Number(props.labelSize) || 7\n        }, [(_slots$label = (_slots$label2 = slots.label) === null || _slots$label2 === void 0 ? void 0 : _slots$label2.call(slots, {\n          index: i,\n          value: item.value\n        })) !== null && _slots$label !== void 0 ? _slots$label : item.value]);\n      })]), _createVNode(\"path\", {\n        \"ref\": path,\n        \"d\": genPath(props.fill),\n        \"fill\": props.fill ? \"url(#\".concat(id.value, \")\") : 'none',\n        \"stroke\": props.fill ? 'none' : \"url(#\".concat(id.value, \")\")\n      }, null), props.fill && _createVNode(\"path\", {\n        \"d\": genPath(false),\n        \"fill\": \"none\",\n        \"stroke\": (_props$color = props.color) !== null && _props$color !== void 0 ? _props$color : (_props$gradient = props.gradient) === null || _props$gradient === void 0 ? void 0 : _props$gradient[0]\n      }, null)]);\n    });\n  }\n});","map":{"version":3,"names":["computed","nextTick","ref","watch","createVNode","_createVNode","makeLineProps","genPath","_genPath","genericComponent","getPropertyFromItem","getUid","propsFactory","useRender","makeVTrendlineProps","_objectSpread","fill","Boolean","VTrendline","name","props","setup","_ref","slots","uid","id","concat","autoDrawDuration","Number","lastLength","path","genPoints","values","boundary","minX","maxX","minY","maxY","totalValues","length","maxValue","max","Math","apply","_toConsumableArray","minValue","min","gridX","gridY","map","value","index","x","y","hasLabels","showLabels","labels","label","lineWidth","parseFloat","totalWidth","width","padding","parseInt","height","items","modelValue","item","itemValue","parsedLabels","points","len","i","_typeof","push","String","_asyncToGenerator","_regeneratorRuntime","mark","_callee","pathRef","wrap","_callee$","_context","prev","next","autoDraw","abrupt","getTotalLength","style","strokeDasharray","strokeDashoffset","getBoundingClientRect","transition","autoDrawEasing","transformOrigin","transform","stop","immediate","smoothValue","smooth","_parseFloat","_props$color","_props$gradient","gradientData","gradient","slice","reverse","gradientDirection","color","textAnchor","dominantBaseline","_slots$label","_slots$label2","labelSize","call"],"sources":["../../../src/components/VSparkline/VTrendline.tsx"],"sourcesContent":["// Utilities\nimport { computed, nextTick, ref, watch } from 'vue'\nimport { makeLineProps } from './util/line'\nimport { genPath as _genPath } from './util/path'\nimport { genericComponent, getPropertyFromItem, getUid, propsFactory, useRender } from '@/util'\n\n// Types\nexport type VTrendlineSlots = {\n  default: void\n  label: { index: number, value: string }\n}\n\nexport type SparklineItem = number | { value: number }\n\nexport type SparklineText = {\n  x: number\n  value: string\n}\n\nexport interface Boundary {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n}\n\nexport interface Point {\n  x: number\n  y: number\n  value: number\n}\n\nexport const makeVTrendlineProps = propsFactory({\n  fill: Boolean,\n\n  ...makeLineProps(),\n}, 'VTrendline')\n\nexport const VTrendline = genericComponent<VTrendlineSlots>()({\n  name: 'VTrendline',\n\n  props: makeVTrendlineProps(),\n\n  setup (props, { slots }) {\n    const uid = getUid()\n    const id = computed(() => props.id || `trendline-${uid}`)\n    const autoDrawDuration = computed(() => Number(props.autoDrawDuration) || (props.fill ? 500 : 2000))\n\n    const lastLength = ref(0)\n    const path = ref<SVGPathElement | null>(null)\n\n    function genPoints (\n      values: number[],\n      boundary: Boundary\n    ): Point[] {\n      const { minX, maxX, minY, maxY } = boundary\n      const totalValues = values.length\n      const maxValue = props.max != null ? Number(props.max) : Math.max(...values)\n      const minValue = props.min != null ? Number(props.min) : Math.min(...values)\n\n      const gridX = (maxX - minX) / (totalValues - 1)\n      const gridY = (maxY - minY) / ((maxValue - minValue) || 1)\n\n      return values.map((value, index) => {\n        return {\n          x: minX + index * gridX,\n          y: maxY - (value - minValue) * gridY,\n          value,\n        }\n      })\n    }\n    const hasLabels = computed(() => {\n      return Boolean(\n        props.showLabels ||\n        props.labels.length > 0 ||\n        !!slots?.label\n      )\n    })\n    const lineWidth = computed(() => {\n      return parseFloat(props.lineWidth) || 4\n    })\n    const totalWidth = computed(() => Number(props.width))\n\n    const boundary = computed<Boundary>(() => {\n      const padding = Number(props.padding)\n\n      return {\n        minX: padding,\n        maxX: totalWidth.value - padding,\n        minY: padding,\n        maxY: parseInt(props.height, 10) - padding,\n      }\n    })\n    const items = computed(() => props.modelValue.map(item => getPropertyFromItem(item, props.itemValue, item)))\n    const parsedLabels = computed(() => {\n      const labels = []\n      const points = genPoints(items.value, boundary.value)\n      const len = points.length\n\n      for (let i = 0; labels.length < len; i++) {\n        const item = points[i]\n        let value = props.labels[i]\n\n        if (!value) {\n          value = typeof item === 'object'\n            ? item.value\n            : item\n        }\n\n        labels.push({\n          x: item.x,\n          value: String(value),\n        })\n      }\n\n      return labels\n    })\n\n    watch(() => props.modelValue, async () => {\n      await nextTick()\n\n      if (!props.autoDraw || !path.value) return\n\n      const pathRef = path.value\n      const length = pathRef.getTotalLength()\n\n      if (!props.fill) {\n        // Initial setup to \"hide\" the line by using the stroke dash array\n        pathRef.style.strokeDasharray = `${length}`\n        pathRef.style.strokeDashoffset = `${length}`\n\n        // Force reflow to ensure the transition starts from this state\n        pathRef.getBoundingClientRect()\n\n        // Animate the stroke dash offset to \"draw\" the line\n        pathRef.style.transition = `stroke-dashoffset ${autoDrawDuration.value}ms ${props.autoDrawEasing}`\n        pathRef.style.strokeDashoffset = '0'\n      } else {\n        // Your existing logic for filled paths remains the same\n        pathRef.style.transformOrigin = 'bottom center'\n        pathRef.style.transition = 'none'\n        pathRef.style.transform = `scaleY(0)`\n        pathRef.getBoundingClientRect()\n        pathRef.style.transition = `transform ${autoDrawDuration.value}ms ${props.autoDrawEasing}`\n        pathRef.style.transform = `scaleY(1)`\n      }\n\n      lastLength.value = length\n    }, { immediate: true })\n\n    function genPath (fill: boolean) {\n      const smoothValue = typeof props.smooth === 'boolean' ? (props.smooth ? 8 : 0) : Number(props.smooth)\n\n      return _genPath(\n        genPoints(items.value, boundary.value),\n        smoothValue,\n        fill,\n        parseInt(props.height, 10)\n      )\n    }\n\n    useRender(() => {\n      const gradientData = !props.gradient.slice().length ? [''] : props.gradient.slice().reverse()\n\n      return (\n        <svg\n          display=\"block\"\n          stroke-width={ parseFloat(props.lineWidth) ?? 4 }\n        >\n          <defs>\n            <linearGradient\n              id={ id.value }\n              gradientUnits=\"userSpaceOnUse\"\n              x1={ props.gradientDirection === 'left' ? '100%' : '0' }\n              y1={ props.gradientDirection === 'top' ? '100%' : '0' }\n              x2={ props.gradientDirection === 'right' ? '100%' : '0' }\n              y2={ props.gradientDirection === 'bottom' ? '100%' : '0' }\n            >\n              {\n                gradientData.map((color, index) => (\n                  <stop offset={ index / (Math.max(gradientData.length - 1, 1)) } stop-color={ color || 'currentColor' } />\n                ))\n              }\n            </linearGradient>\n          </defs>\n\n          { hasLabels.value && (\n            <g\n              key=\"labels\"\n              style={{\n                textAnchor: 'middle',\n                dominantBaseline: 'mathematical',\n                fill: 'currentColor',\n              }}\n            >\n              {\n                parsedLabels.value.map((item, i) => (\n                  <text\n                    x={ item.x + (lineWidth.value / 2) + lineWidth.value / 2 }\n                    y={ (parseInt(props.height, 10) - 4) + (parseInt(props.labelSize, 10) || 7 * 0.75) }\n                    font-size={ Number(props.labelSize) || 7 }\n                  >\n                    { slots.label?.({ index: i, value: item.value }) ?? item.value }\n                  </text>\n                ))\n              }\n            </g>\n          )}\n\n          <path\n            ref={ path }\n            d={ genPath(props.fill) }\n            fill={ props.fill ? `url(#${id.value})` : 'none' }\n            stroke={ props.fill ? 'none' : `url(#${id.value})` }\n          />\n\n          { props.fill && (\n            <path\n              d={ genPath(false) }\n              fill=\"none\"\n              stroke={ props.color ?? props.gradient?.[0] }\n            />\n          )}\n        </svg>\n      )\n    })\n  },\n})\n\nexport type VTrendline = InstanceType<typeof VTrendline>\n"],"mappings":";;;;;;;;;;;;;;;;;AAAA;AACA,SAASA,QAAQ,EAAEC,QAAQ,EAAEC,GAAG,EAAEC,KAAK,EAAAC,WAAA,IAAAC,YAAA,QAAQ,KAAK;AAAA,SAC3CC,aAAa;AAAA,SACbC,OAAO,IAAIC,QAAQ;AAAA,SACnBC,gBAAgB,EAAEC,mBAAmB,EAAEC,MAAM,EAAEC,YAAY,EAAEC,SAAS,gCAE/E;AA0BA,OAAO,IAAMC,mBAAmB,GAAGF,YAAY,CAAAG,aAAA;EAC7CC,IAAI,EAAEC;AAAO,GAEVX,aAAa,CAAC,IAChB,YAAY,CAAC;AAEhB,OAAO,IAAMY,UAAU,GAAGT,gBAAgB,CAAkB,CAAC,CAAC;EAC5DU,IAAI,EAAE,YAAY;EAElBC,KAAK,EAAEN,mBAAmB,CAAC,CAAC;EAE5BO,KAAK,WAALA,KAAKA,CAAED,KAAK,EAAAE,IAAA,EAAa;IAAA,IAATC,KAAA,GAAOD,IAAA,CAAPC,KAAA;IACd,IAAMC,GAAG,GAAGb,MAAM,CAAC,CAAC;IACpB,IAAMc,EAAE,GAAGzB,QAAQ,CAAC;MAAA,OAAMoB,KAAK,CAACK,EAAE,iBAAAC,MAAA,CAAiBF,GAAG,CAAE;IAAA,EAAC;IACzD,IAAMG,gBAAgB,GAAG3B,QAAQ,CAAC;MAAA,OAAM4B,MAAM,CAACR,KAAK,CAACO,gBAAgB,CAAC,KAAKP,KAAK,CAACJ,IAAI,GAAG,GAAG,GAAG,IAAI,CAAC;IAAA,EAAC;IAEpG,IAAMa,UAAU,GAAG3B,GAAG,CAAC,CAAC,CAAC;IACzB,IAAM4B,IAAI,GAAG5B,GAAG,CAAwB,IAAI,CAAC;IAE7C,SAAS6B,SAASA,CAChBC,MAAgB,EAChBC,QAAkB,EACT;MACT,IAAQC,IAAI,GAAuBD,QAAQ,CAAnCC,IAAI;QAAEC,IAAI,GAAiBF,QAAQ,CAA7BE,IAAI;QAAEC,IAAI,GAAWH,QAAQ,CAAvBG,IAAI;QAAEC,IAAA,GAASJ,QAAQ,CAAjBI,IAAA;MAC1B,IAAMC,WAAW,GAAGN,MAAM,CAACO,MAAM;MACjC,IAAMC,QAAQ,GAAGpB,KAAK,CAACqB,GAAG,IAAI,IAAI,GAAGb,MAAM,CAACR,KAAK,CAACqB,GAAG,CAAC,GAAGC,IAAI,CAACD,GAAG,CAAAE,KAAA,CAARD,IAAI,EAAAE,kBAAA,CAAQZ,MAAM,EAAC;MAC5E,IAAMa,QAAQ,GAAGzB,KAAK,CAAC0B,GAAG,IAAI,IAAI,GAAGlB,MAAM,CAACR,KAAK,CAAC0B,GAAG,CAAC,GAAGJ,IAAI,CAACI,GAAG,CAAAH,KAAA,CAARD,IAAI,EAAAE,kBAAA,CAAQZ,MAAM,EAAC;MAE5E,IAAMe,KAAK,GAAG,CAACZ,IAAI,GAAGD,IAAI,KAAKI,WAAW,GAAG,CAAC,CAAC;MAC/C,IAAMU,KAAK,GAAG,CAACX,IAAI,GAAGD,IAAI,KAAMI,QAAQ,GAAGK,QAAQ,IAAK,CAAC,CAAC;MAE1D,OAAOb,MAAM,CAACiB,GAAG,CAAC,UAACC,KAAK,EAAEC,KAAK,EAAK;QAClC,OAAO;UACLC,CAAC,EAAElB,IAAI,GAAGiB,KAAK,GAAGJ,KAAK;UACvBM,CAAC,EAAEhB,IAAI,GAAG,CAACa,KAAK,GAAGL,QAAQ,IAAIG,KAAK;UACpCE,KAAA,EAAAA;QACF,CAAC;MACH,CAAC,CAAC;IACJ;IACA,IAAMI,SAAS,GAAGtD,QAAQ,CAAC,YAAM;MAC/B,OAAOiB,OAAO,CACZG,KAAK,CAACmC,UAAU,IAChBnC,KAAK,CAACoC,MAAM,CAACjB,MAAM,GAAG,CAAC,IACvB,CAAC,EAAChB,KAAK,aAALA,KAAK,eAALA,KAAK,CAAEkC,KACX,EAAC;IACH,CAAC,CAAC;IACF,IAAMC,SAAS,GAAG1D,QAAQ,CAAC,YAAM;MAC/B,OAAO2D,UAAU,CAACvC,KAAK,CAACsC,SAAS,CAAC,IAAI,CAAC;IACzC,CAAC,CAAC;IACF,IAAME,UAAU,GAAG5D,QAAQ,CAAC;MAAA,OAAM4B,MAAM,CAACR,KAAK,CAACyC,KAAK,CAAC;IAAA,EAAC;IAEtD,IAAM5B,QAAQ,GAAGjC,QAAQ,CAAW,YAAM;MACxC,IAAM8D,OAAO,GAAGlC,MAAM,CAACR,KAAK,CAAC0C,OAAO,CAAC;MAErC,OAAO;QACL5B,IAAI,EAAE4B,OAAO;QACb3B,IAAI,EAAEyB,UAAU,CAACV,KAAK,GAAGY,OAAO;QAChC1B,IAAI,EAAE0B,OAAO;QACbzB,IAAI,EAAE0B,QAAQ,CAAC3C,KAAK,CAAC4C,MAAM,EAAE,EAAE,CAAC,GAAGF;MACrC,CAAC;IACH,CAAC,CAAC;IACF,IAAMG,KAAK,GAAGjE,QAAQ,CAAC;MAAA,OAAMoB,KAAK,CAAC8C,UAAU,CAACjB,GAAG,CAAC,UAAAkB,IAAI;QAAA,OAAIzD,mBAAmB,CAACyD,IAAI,EAAE/C,KAAK,CAACgD,SAAS,EAAED,IAAI,CAAC;MAAA,EAAC;IAAA,EAAC;IAC5G,IAAME,YAAY,GAAGrE,QAAQ,CAAC,YAAM;MAClC,IAAMwD,MAAM,GAAG,EAAE;MACjB,IAAMc,MAAM,GAAGvC,SAAS,CAACkC,KAAK,CAACf,KAAK,EAAEjB,QAAQ,CAACiB,KAAK,CAAC;MACrD,IAAMqB,GAAG,GAAGD,MAAM,CAAC/B,MAAM;MAEzB,KAAK,IAAIiC,CAAC,GAAG,CAAC,EAAEhB,MAAM,CAACjB,MAAM,GAAGgC,GAAG,EAAEC,CAAC,EAAE,EAAE;QACxC,IAAML,IAAI,GAAGG,MAAM,CAACE,CAAC,CAAC;QACtB,IAAItB,KAAK,GAAG9B,KAAK,CAACoC,MAAM,CAACgB,CAAC,CAAC;QAE3B,IAAI,CAACtB,KAAK,EAAE;UACVA,KAAK,GAAGuB,OAAA,CAAON,IAAI,MAAK,QAAQ,GAC5BA,IAAI,CAACjB,KAAK,GACViB,IAAI;QACV;QAEAX,MAAM,CAACkB,IAAI,CAAC;UACVtB,CAAC,EAAEe,IAAI,CAACf,CAAC;UACTF,KAAK,EAAEyB,MAAM,CAACzB,KAAK;QACrB,CAAC,CAAC;MACJ;MAEA,OAAOM,MAAM;IACf,CAAC,CAAC;IAEFrD,KAAK,CAAC;MAAA,OAAMiB,KAAK,CAAC8C,UAAU;IAAA,gBAAAU,iBAAA,cAAAC,mBAAA,GAAAC,IAAA,CAAE,SAAAC,QAAA;MAAA,IAAAC,OAAA,EAAAzC,MAAA;MAAA,OAAAsC,mBAAA,GAAAI,IAAA,UAAAC,SAAAC,QAAA;QAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;UAAA;YAAAF,QAAA,CAAAE,IAAA;YAAA,OACtBpF,QAAQ,CAAC,CAAC;UAAA;YAAA,MAEZ,CAACmB,KAAK,CAACkE,QAAQ,IAAI,CAACxD,IAAI,CAACoB,KAAK;cAAAiC,QAAA,CAAAE,IAAA;cAAA;YAAA;YAAA,OAAAF,QAAA,CAAAI,MAAA;UAAA;YAE5BP,OAAO,GAAGlD,IAAI,CAACoB,KAAK;YACpBX,MAAM,GAAGyC,OAAO,CAACQ,cAAc,CAAC,CAAC;YAEvC,IAAI,CAACpE,KAAK,CAACJ,IAAI,EAAE;cACf;cACAgE,OAAO,CAACS,KAAK,CAACC,eAAe,MAAAhE,MAAA,CAAMa,MAAM,CAAE;cAC3CyC,OAAO,CAACS,KAAK,CAACE,gBAAgB,MAAAjE,MAAA,CAAMa,MAAM,CAAE;;cAE5C;cACAyC,OAAO,CAACY,qBAAqB,CAAC,CAAC;;cAE/B;cACAZ,OAAO,CAACS,KAAK,CAACI,UAAU,wBAAAnE,MAAA,CAAwBC,gBAAgB,CAACuB,KAAK,SAAAxB,MAAA,CAAMN,KAAK,CAAC0E,cAAc,CAAE;cAClGd,OAAO,CAACS,KAAK,CAACE,gBAAgB,GAAG,GAAG;YACtC,CAAC,MAAM;cACL;cACAX,OAAO,CAACS,KAAK,CAACM,eAAe,GAAG,eAAe;cAC/Cf,OAAO,CAACS,KAAK,CAACI,UAAU,GAAG,MAAM;cACjCb,OAAO,CAACS,KAAK,CAACO,SAAS,cAAc;cACrChB,OAAO,CAACY,qBAAqB,CAAC,CAAC;cAC/BZ,OAAO,CAACS,KAAK,CAACI,UAAU,gBAAAnE,MAAA,CAAgBC,gBAAgB,CAACuB,KAAK,SAAAxB,MAAA,CAAMN,KAAK,CAAC0E,cAAc,CAAE;cAC1Fd,OAAO,CAACS,KAAK,CAACO,SAAS,cAAc;YACvC;YAEAnE,UAAU,CAACqB,KAAK,GAAGX,MAAM;UAAA;UAAA;YAAA,OAAA4C,QAAA,CAAAc,IAAA;QAAA;MAAA,GAAAlB,OAAA;IAAA,CAC1B,IAAE;MAAEmB,SAAS,EAAE;IAAK,CAAC,CAAC;IAEvB,SAAS3F,OAAOA,CAAES,IAAa,EAAE;MAC/B,IAAMmF,WAAW,GAAG,OAAO/E,KAAK,CAACgF,MAAM,KAAK,SAAS,GAAIhF,KAAK,CAACgF,MAAM,GAAG,CAAC,GAAG,CAAC,GAAIxE,MAAM,CAACR,KAAK,CAACgF,MAAM,CAAC;MAErG,OAAO5F,QAAQ,CACbuB,SAAS,CAACkC,KAAK,CAACf,KAAK,EAAEjB,QAAQ,CAACiB,KAAK,CAAC,EACtCiD,WAAW,EACXnF,IAAI,EACJ+C,QAAQ,CAAC3C,KAAK,CAAC4C,MAAM,EAAE,EAAE,CAC3B,CAAC;IACH;IAEAnD,SAAS,CAAC,YAAM;MAAA,IAAAwF,WAAA,EAAAC,YAAA,EAAAC,eAAA;MACd,IAAMC,YAAY,GAAG,CAACpF,KAAK,CAACqF,QAAQ,CAACC,KAAK,CAAC,CAAC,CAACnE,MAAM,GAAG,CAAC,EAAE,CAAC,GAAGnB,KAAK,CAACqF,QAAQ,CAACC,KAAK,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;MAE7F,OAAAtG,YAAA;QAAA;QAAA,iBAAAgG,WAAA,GAGmB1C,UAAU,CAACvC,KAAK,CAACsC,SAAS,CAAC,cAAA2C,WAAA,cAAAA,WAAA,GAAI;MAAC,IAAAhG,YAAA,gBAAAA,YAAA;QAAA,MAItCoB,EAAE,CAACyB,KAAK;QAAA;QAAA,MAER9B,KAAK,CAACwF,iBAAiB,KAAK,MAAM,GAAG,MAAM,GAAG,GAAG;QAAA,MACjDxF,KAAK,CAACwF,iBAAiB,KAAK,KAAK,GAAG,MAAM,GAAG,GAAG;QAAA,MAChDxF,KAAK,CAACwF,iBAAiB,KAAK,OAAO,GAAG,MAAM,GAAG,GAAG;QAAA,MAClDxF,KAAK,CAACwF,iBAAiB,KAAK,QAAQ,GAAG,MAAM,GAAG;MAAG,IAGtDJ,YAAY,CAACvD,GAAG,CAAC,UAAC4D,KAAK,EAAE1D,KAAK;QAAA,OAAA9C,YAAA;UAAA,UACb8C,KAAK,GAAIT,IAAI,CAACD,GAAG,CAAC+D,YAAY,CAACjE,MAAM,GAAG,CAAC,EAAE,CAAC,CAAE;UAAA,cAAgBsE,KAAK,IAAI;QAAc,QACrG;MAAA,EAAC,MAKNvD,SAAS,CAACJ,KAAK,IAAA7C,YAAA;QAAA;QAAA,SAGN;UACLyG,UAAU,EAAE,QAAQ;UACpBC,gBAAgB,EAAE,cAAc;UAChC/F,IAAI,EAAE;QACR;MAAC,IAGCqD,YAAY,CAACnB,KAAK,CAACD,GAAG,CAAC,UAACkB,IAAI,EAAEK,CAAC;QAAA,IAAAwC,YAAA,EAAAC,aAAA;QAAA,OAAA5G,YAAA;UAAA,KAEvB8D,IAAI,CAACf,CAAC,GAAIM,SAAS,CAACR,KAAK,GAAG,CAAE,GAAGQ,SAAS,CAACR,KAAK,GAAG,CAAC;UAAA,KACnDa,QAAQ,CAAC3C,KAAK,CAAC4C,MAAM,EAAE,EAAE,CAAC,GAAG,CAAC,IAAKD,QAAQ,CAAC3C,KAAK,CAAC8F,SAAS,EAAE,EAAE,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;UAAA,aACtEtF,MAAM,CAACR,KAAK,CAAC8F,SAAS,CAAC,IAAI;QAAC,KAAAF,YAAA,IAAAC,aAAA,GAEtC1F,KAAK,CAACkC,KAAK,cAAAwD,aAAA,uBAAXA,aAAA,CAAAE,IAAA,CAAA5F,KAAK,EAAS;UAAE4B,KAAK,EAAEqB,CAAC;UAAEtB,KAAK,EAAEiB,IAAI,CAACjB;QAAM,CAAC,CAAC,cAAA8D,YAAA,cAAAA,YAAA,GAAI7C,IAAI,CAACjB,KAAK,EAEjE;MAAA,EAAC,EAGP,EAAA7C,YAAA;QAAA,OAGOyB,IAAI;QAAA,KACNvB,OAAO,CAACa,KAAK,CAACJ,IAAI,CAAC;QAAA,QAChBI,KAAK,CAACJ,IAAI,WAAAU,MAAA,CAAWD,EAAE,CAACyB,KAAK,SAAM,MAAM;QAAA,UACvC9B,KAAK,CAACJ,IAAI,GAAG,MAAM,WAAAU,MAAA,CAAWD,EAAE,CAACyB,KAAK;MAAG,UAGlD9B,KAAK,CAACJ,IAAI,IAAAX,YAAA;QAAA,KAEJE,OAAO,CAAC,KAAK,CAAC;QAAA;QAAA,WAAA+F,YAAA,GAETlF,KAAK,CAACyF,KAAK,cAAAP,YAAA,cAAAA,YAAA,IAAAC,eAAA,GAAInF,KAAK,CAACqF,QAAQ,cAAAF,eAAA,uBAAdA,eAAA,CAAiB,CAAC;MAAC,QAE9C;IAGP,CAAC,CAAC;EACJ;AACF,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}